name: Release (Proton-GE Manager — Linux AppImage)

on:
  push:
    tags:
      - 'v*'     # build & publish when you push a tag
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag name to publish (e.g., v1.0.0) if running manually"
        required: false
        type: string
      prerelease:
        description: "Mark release as prerelease?"
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  id-token: write

env:
  APP_ID:   com.sirrandall.protonge.manager
  APP_NAME: Proton-GE Manager
  ICON_PATH: ./internal/assets/icon.png
  SRC_DIR:  ./cmd
  GO_VERSION: "1.25.4"

jobs:
  build-appimage:
    runs-on: ubuntu-22.04

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install build deps (GL/X11, tools)
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential gcc pkg-config \
            libgl1-mesa-dev xorg-dev \
            libxrandr-dev libxxf86vm-dev libxi-dev libxcursor-dev libxinerama-dev \
            libfuse2 wget curl desktop-file-utils squashfs-tools

      - name: Force local toolchain & isolate caches
        run: |
          # Force Go to use the installed toolchain only (no golang.org/toolchain download)
          go env -w GOTOOLCHAIN=local

          # Isolate caches into the workspace to avoid tar collisions
          echo "GOMODCACHE=$GITHUB_WORKSPACE/.gomodcache" >> $GITHUB_ENV
          echo "GOCACHE=$GITHUB_WORKSPACE/.gocache"       >> $GITHUB_ENV

          # Ensure clean dirs
          rm -rf "$GITHUB_WORKSPACE/.gomodcache" "$GITHUB_WORKSPACE/.gocache"
          mkdir -p "$GITHUB_WORKSPACE/.gomodcache" "$GITHUB_WORKSPACE/.gocache"

      - name: Build linux amd64 binary
        env:
          CGO_ENABLED: "1"
        run: |
          set -euo pipefail

          mkdir -p dist

          echo "SRC_DIR=$SRC_DIR"
          ls -la "$SRC_DIR"

          # Build explicitly for AMD64 from ./cmd, output to ./dist
          GOOS=linux GOARCH=amd64 CGO_ENABLED=1 \
            go build -C "$SRC_DIR" -trimpath -ldflags "-s -w" \
              -o "$GITHUB_WORKSPACE/dist/proton-ge-manager" .

          echo "=== dist contents ==="
          ls -la dist
          file dist/proton-ge-manager || true

          # Hard fail if binary not there
          test -f dist/proton-ge-manager

          chmod +x dist/proton-ge-manager

      - name: Assemble AppDir
        env:
          APP_ID:   ${{ env.APP_ID }}
          APP_NAME: ${{ env.APP_NAME }}
          ICON_PATH: ${{ env.ICON_PATH }}
        run: |
          set -euo pipefail

          APPDIR="AppDir"
          BIN_NAME="proton-ge-manager"
          DESKTOP_NAME="${APP_ID}.desktop"
          ICON_NAME="${APP_ID}.png"

          rm -rf "${APPDIR}"
          mkdir -p "${APPDIR}/usr/bin"
          mkdir -p "${APPDIR}/usr/share/applications"
          mkdir -p "${APPDIR}/usr/share/icons/hicolor/256x256/apps"

          # Binary
          cp dist/${BIN_NAME} "${APPDIR}/usr/bin/${BIN_NAME}"
          chmod +x "${APPDIR}/usr/bin/${BIN_NAME}"

          # Desktop file
          cat > "${APPDIR}/${DESKTOP_NAME}" <<EOF
          [Desktop Entry]
          Type=Application
          Name=${APP_NAME}
          Comment=${APP_NAME}
          Exec=${BIN_NAME}
          Icon=${APP_ID}
          Terminal=false
          Categories=Utility;
          EOF

          # Icon
          echo "ICON_PATH=$ICON_PATH"
          if [ -f "${ICON_PATH}" ]; then
            cp "${ICON_PATH}" "${APPDIR}/${ICON_NAME}"
            cp "${ICON_PATH}" "${APPDIR}/usr/share/icons/hicolor/256x256/apps/${ICON_NAME}"
          else
            echo "WARNING: Icon missing: ${ICON_PATH}"
            : > "${APPDIR}/${ICON_NAME}"
          fi
          ln -sf "${ICON_NAME}" "${APPDIR}/.DirIcon" || true

          # Copy desktop file
          cp "${APPDIR}/${DESKTOP_NAME}" "${APPDIR}/usr/share/applications/${DESKTOP_NAME}"

          # AppRun launcher
          cat > "${APPDIR}/AppRun" << 'EOF'
          #!/usr/bin/env sh
          HERE="$(dirname "$(readlink -f "$0")")"
          export PATH="$HERE/usr/bin:$PATH"
          exec "$HERE/usr/bin/proton-ge-manager" "$@"
          EOF
          chmod +x "${APPDIR}/AppRun"

          desktop-file-validate -v "${APPDIR}/${DESKTOP_NAME}" || true

      - name: Build AppImage
        env:
          APP_NAME: ${{ env.APP_NAME }}
          APP_ID:   ${{ env.APP_ID }}
        run: |
          set -euo pipefail
          echo "Downloading appimagetool (with fallbacks)…"

          urls=(
            "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage"
            "https://github.com/AppImage/AppImageKit/releases/download/13/appimagetool-x86_64.AppImage"
            "https://github.com/AppImage/AppImageKit/releases/latest/download/appimagetool-x86_64.AppImage"
          )

          rm -f appimagetool || true
          ok=0
          for u in "${urls[@]}"; do
            echo "Trying: $u"
            if curl -fL --retry 5 --retry-delay 2 --retry-all-errors -o appimagetool "$u"; then
              ok=1; break
            fi
          done
          if [ "$ok" -ne 1 ]; then
            echo "Failed to download appimagetool from all sources"
            exit 1
          fi
          chmod +x appimagetool

          # Some runners have FUSE quirks; fall back to extracted AppRun if needed
          APPIMG="./appimagetool"
          if ! "$APPIMG" --version >/dev/null 2>&1; then
            echo "Direct execution failed, extracting AppImage…"
            ./appimagetool --appimage-extract >/dev/null 2>&1 || true
            if [ -x "./squashfs-root/AppRun" ]; then
              APPIMG="./squashfs-root/AppRun"
              "$APPIMG" --version || true
            else
              echo "Extraction failed; cannot find squashfs-root/AppRun"
              exit 1
            fi
          fi

          # Validate AppDir
          test -x AppDir/AppRun
          test -f "AppDir/${APP_ID}.desktop"
          test -f "AppDir/${APP_ID}.png"

          export VERSION="${GITHUB_REF_NAME:-$(date +%Y%m%d)}"

          # Build AppImage (verbose, skip appstream)
          "$APPIMG" -v --no-appstream AppDir "${APP_NAME}.AppImage" 2>&1 | tee appimagetool.log

          mkdir -p dist
          chmod +x "${APP_NAME}.AppImage"
          mv "${APP_NAME}.AppImage" dist/proton-ge-manager-linux-x86_64.AppImage

      # ✅ Upload artifact so publish job can fetch it
      - name: Upload AppImage artifact
        uses: actions/upload-artifact@v4
        with:
          name: proton-ge-manager-appimage
          path: dist/proton-ge-manager-linux-x86_64.AppImage
          if-no-files-found: error

  publish:
    needs: [build-appimage]
    runs-on: ubuntu-22.04
    env:
      TAG: ${{ github.ref_type == 'tag' && github.ref_name || inputs.tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Fail if no tag was provided
        if: ${{ github.ref_type != 'tag' && (inputs.tag == '' || inputs.tag == null) }}
        run: |
          echo "Missing tag. Supply a tag (e.g., v1.0.0) when triggering manually."
          exit 1

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist
          merge-multiple: true

      - name: Ensure AppImage exists
        run: |
          echo "== dist tree =="
          find dist -maxdepth 3 -type f -printf "%p\n" | sort || true
          test -n "$(find dist -name '*.AppImage' -type f -print -quit)" || {
            echo "No AppImage found in dist/"
            exit 1
          }

      - name: Upload AppImage to Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.TAG }}
          generate_release_notes: true
          make_latest: true
          prerelease: ${{ inputs.prerelease == true }}
          files: |
            dist/**/*.AppImage